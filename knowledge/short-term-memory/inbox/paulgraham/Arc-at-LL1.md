---
title: "Arc at LL1"
author: Paul Graham
source: http://paulgraham.com/arcll1.html
year_published: 2001
date_scraped: 2025-08-07
time_scraped: 14:34:56
word_count: 5155
scrape_method: firecrawl
tags: [paul-graham, essays, startups, programming, philosophy]
---

# Arc at LL1

|     |     |     |
| --- | --- | --- |
| ![](https://s.turbifycdn.com/aah/paulgraham/essays-5.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [![](https://s.turbifycdn.com/aah/paulgraham/essays-6.gif)](https://paulgraham.com/index.html)

|     |
| --- |
| ![Arc: An Unfinished Dialect of Lisp](https://s.turbifycdn.com/aah/paulgraham/arc-at-3-weeks-2.gif)<br>November 2001<br>* * *<br>1\. Preliminaries:<br>\- Arc isn't finished.<br>\- Suggestions are invited.<br>\- Don't be too shocked (you may get used to it).<br>* * *<br>Arc was the youngest language presented at LL1. It's about<br>three weeks old. Most languages probably look pretty bad<br>at that age, but I wanted to show Arc to people early on<br>to get their opinions.<br>A few of the ideas in Arc will seem <br>shocking, especially to compiler writers. So bear with us.<br>Some of these ideas will seem less shocking with time. <br>Others may actually suck, and we'll redo those.<br>* * *<br>2\. Lisp<br>\- A language with dialects.<br>\- No new Lisp since mid 80s (and not new then).<br>\- Languages different now:<br> Unix won,<br> big libraries,<br> active development.<br>\- No onions in the varnish.<br>* * *<br>Lisp is an unusual language because it has dialects. Lisp<br>depends on a small, definite, core of operators, and any language<br>that has these operators is a dialect of Lisp-- not just<br>as a social custom, but in the formal sense that if you<br>have the core operators you can define all the rest. If<br>you design a language that has car, cdr, cons, quote, eq,<br>cond, and a notation for functions made of conses, then you've <br>designed a dialect of Lisp, even if you didn't mean to.<br>It's about time for a new dialect of Lisp. The two leading<br>dialects, Common Lisp and Scheme, have not been substantially<br>changed since the 1980s. What a language is has changed<br>since then. In 1985, a programming language was just a spec.<br>Now, thanks to Perl, it means not just (and maybe not even) a spec,<br>but also a good free implementation, huge libraries, and<br>constant updates.<br>Another thing has changed since 1985: Unix won. So there is a lot<br>more agreement now about what you can expect from the OS.<br>Common Lisp and Scheme date from a time when languages had to<br>be OS-neutral. A programming language couldn't have a concept<br>of a socket, for example; what if the underlying OS didn't<br>have sockets? That has changed. Now a<br>language that won't let you open a socket seems almost <br>perversely inconvenient.<br>If you just made a Lisp that could talk to the OS and<br>had powerful string libraries, I think it would more than<br>hold its own.<br>We're hoping to do more than that though. The aim with Arc<br>is not to update Common Lisp or Scheme.<br>In Arc we're going to try to go back to the origins of Lisp,<br>in McCarthy's 1960 paper, and rebuild the language from<br>the bottom.<br>In _The Periodic Table,_ Primo Levi tells a story that<br>happened when he was working in a varnish factory. He <br>was a chemist, and he was fascinated by the fact that<br>the varnish recipe included<br>a raw onion. What could it be for? No one knew; it was just<br>part of the recipe. So he investigated, and eventually<br>discovered that they had started throwing the onion in years<br>ago to test the temperature of the varnish: if it was<br>hot enough, the onion would fry.<br>We're going to try not to include any onions in Arc. Everything<br>is open to question. For example, in Arc, lambda is called fn.<br>This idea appalled me at first, but it seemed<br>like fn would be shorter and at least as expressive. What if I<br>was just used to lambda? So, with a queasy sense of duty,<br>I decided to try it. And after a few<br>days I actually liked fn better. Now it seems clear to me<br>that lambda is an onion: Alonzo Church himself wouldn't have<br>used it if he had to write out the word lambda each time.<br>* * *<br>3\. A Language for Good Programmers<br>\- Target user: opposite of Java.<br>\- Programmable programming language.<br>\- By default, allow.<br>\- The language I wish someone would make for me.<br>\- Brevity (what you like about abstraction)<br>* * *<br>Java was, as<br>Gosling says in the first Java white paper, designed for<br>average programmers.<br>It's a perfectly legitimate goal to design a language for<br>average programmers. (Or for that matter for small children,<br>like Logo.) But it is also a legitimate, and very different,<br>goal to design a language for [good programmers](https://paulgraham.com/design.html).<br>Languages designed for average programmers have to put safety first.<br>Expert programmers, on the other hand, care only about power, <br>and are going to be annoyed with any language that gets in their<br>way in the name of safety. You see this difference<br>in any tool, from cars to dishwashers.<br>I don't know if anyone has consciously designed a language<br>for good programmers before. There have been several languages<br>that were in effect designed for good programmers, because<br>good programmers designed them for their own use. C, Lisp, and<br>Smalltalk all came about this way.<br>In some ways it makes the problem easier when you can assume the<br>user is a good programmer. Language designers often find<br>themselves worrying about the mess users might make if they<br>were allowed to do such-and-such. Once you assume the user<br>is a good programmer, you automatically have the answer to <br>any such question: let the user do whatever he wants.<br>Lisp has always been way down that end of the continuum.<br>[John Foderaro](https://paulgraham.com/chameleon.html) called <br>it "the programmable programming language",<br>because there is so much the programmer can change. Arc<br>aims to maximize this aspect of Lisp. Instead of assuming <br>that we know what's good for the programmer to be allowed to<br>get his hands on, we assume that the programmer will want to<br>do things we never even imagined, and so will need to be able to<br>get his hands on everything.<br>Another thing good programmers like is brevity, and that is<br>Arc's other main goal. You often hear that programming<br>languages are good because they provide abstraction.<br>I think what we really like is<br>not abstraction per se but brevity. A way of expressing <br>programs that was more abstract, but made your programs <br>longer, would not be very enticing. (This is not just a<br>hypothetical example. It happens in Prolog.)<br>By brevity I don't mean that programs should require<br>fewer characters. That counts for something, but it is<br>more important to require fewer tokens.<br>Perl is an inspiring example of brevity. Larry Wall<br>broke all the rules, and in the process discovered some<br>good ideas. Perl may be a kludge, but it makes your programs<br>short, and you have to respect that.<br>In Arc we<br>hope to make programs as short or shorter, but at the<br>same time to build the language up in a transparent way<br>from clearly understood foundations.<br>We're not doing this (just) out of fastidiousness. You have<br>to build the language up transparently if you want<br>users to be able to customize it. The chaotic semantics<br>of Perl would make it very hard to add macros.<br>* * *<br>4\. Other Principles<br>\- Do what programmers actually (secretly) want.<br>\- How code looks matters: short names, no swearing<br>\- Polymorphism: (+ "foo" "bar") -> "foobar"<br>\- Specially suited for Web apps.<br>\- Perl lesson: pronouns.<br>* * *<br>We have a couple other design goals for Arc. We try to<br>keep in mind that languages are for programmers, and so<br>should do what programmers want. What programmers actually<br>want may not be the same thing as what language designers<br>consider to be good design. In such cases the language<br>designers should toss their principles and listen to<br>the programmers.<br>You don't want to be like a modernist architect who<br>designs a chair that is all right angles to conform to<br>some preconceived idea of good design. All you're doing<br>then is solving the wrong problem. Chairs (except for<br>a few that are explicitly designed as sculpture) are<br>for people to sit in.<br>I was asking a friend of mine, who is just about the best<br>programmer you could hope to meet, about creating new<br>local variables. With some hesitation he admitted that<br>he disliked the traditional Lisp let, because it<br>introduced a new level of indentation as well. He was<br>hesitant because he knew, in principle,<br>that let was the "right" thing. At this point, you have<br>to ask, "right for who?" because I don't think there are<br>any programmers substantially smarter than this guy.<br>If he wants to do something a certain way, that's the <br>best test you'll get of what is good design-- better,<br>certainly, than any abstract principle.<br>Another thing programmers are reluctant to admit, but <br>which almost all feel fairly strongly, is that it matters<br>how code looks. Well, it does matter, a lot. We are<br>going to try hard not only to make Arc beautiful, but to<br>let you change the way the language looks if your idea<br>of beauty is different.<br>Software designers usually fall into either the short-name<br>school or the long-name school. Unix and C favor short<br>names. Common Lisp and Smalltalk are in the opposite camp.<br>The argument for long names is that they are more descriptive,<br>and so make it easier for programmers, especially beginners,<br>to remember what the underlying operators do. The argument<br>against long names is that they clutter up your program.<br>Here again we are saved by our axiom that the user is a<br>good programmer. We assume the user doesn't need operators<br>to be called multiple-value-bind or invoke-restart-interactively<br>to remember what they do.<br>On the other hand, we're also going to try<br>not to make the language look like a cartoon<br>character swearing. Have you ever noticed that when you<br>fill out some kind of Web form you tend to use all lowercase?<br>Ordinary lowercase letters are less work to type than<br>characters like #&%$. (Dan Giffin recently observed that<br>if you measure Perl programs by the number of keys you<br>have to press, they don't seem so short.) And<br>lowercase letters are easier to read as well.<br>You have to hit a kind of mental shift key to read<br>symbols. As far as we can we're going to make Arc a<br>smoothly lowercase language.<br>Another thing many good programmers have in common is<br>incipient carpal tunnel syndrome, so a language that's <br>easy to type should be a win for them.<br>Arc is quite polymorphic. The + function both adds numbers<br>and concatentates strings. Having a separate operator for<br>each is equivalent to having one operator, plus a <br>type declaration. Having a single operator for both is<br>equivalent to letting the programmer omit the declaration.<br>Every language should be designed together with a big <br>application written in it, so the designers can see whether<br>the language works. C, for example, was sharpened on <br>the systems programming projects that culminated in Unix.<br>We're going to use Arc to write a<br>platform for Web-based applications. The two will<br>be tightly integrated, like C and Unix. We hope to make <br>Arc the ideal language for writing Web-based apps-- <br>the language we wish we'd had when we were<br>writing [Viaweb](https://paulgraham.com/avg.html). This means that<br>Arc will have to be good at manipulating strings, which<br>has not in the past been a big concern for Lisp.<br>One of the ways Perl makes programs shorter is to use<br>a lot of pronouns. Lisp programmers have always done this<br>to some extent with macros like aif, but it has generally been<br>considered a slightly dubious trick, and has not as far<br>as I know made it into any of the major Lisp dialects.<br>In Arc we use a lot of pronouns. They make programs shorter,<br>and having them gives more control to the programmer. <br>(If a language lets things be implicit, the programmer <br>always has the option of being explicit, but if the<br>languages requires everything to be explicit, the<br>programmer can't make things implicit.)<br>* * *<br>5\. Syntax<br>\- CL/Scheme: s-expressions only.<br> disadvantage: long-winded<br>\- Dylan/Python: s-expressions hidden underneath.<br> disadvantage: macros unnatural<br>\- Arc: syntax as abbreviation.<br> disadvantage: no syntax yet<br>* * *<br>Arc is going to have syntax. The Lisp world has agonized<br>about this [question](https://paulgraham.com/syntaxquestion.html) for a long time. Since the beginning<br>in fact, as several people pointed out at LL1. McCarthy<br>intended the original Lisp to have syntax, but<br>programmers preferred using raw s-expressions, so no<br>one ever got around to implementing it.<br>The argument for syntax has usually been that it would<br>make Lisp more accessible to a "mainstream" audience.<br>The designers of Dylan, which was intended to be Lisp for the<br>masses, dutifully stuck a syntax onto the later versions. I<br>didn't get the impression that they, personally, preferred<br>writing programs in the new syntax. That is dangerous territory.<br>By deciding to make Arc a language for good programmers,<br>we get an answer to that side of the question at least.<br>We don't have to dumb down the language to make it<br>accessible to anyone.<br>However, there is another advantage of syntax: it can make <br>programs shorter. And that is a genuine win.<br>So the answer (or an answer), I think, to the long<br>pondered question of syntax for Lisp is: yes, have syntax,<br>but only as abbreviation. Arc will have syntax, but it <br>will translate in a clearly defined (and in fact, redefinable)<br>way into underlying s-expressions. Nearly all the syntax will<br>be optional, and moreover optional at the level of<br>individual operators.<br>As much as we can, we will make whatever we use to define<br>syntax accessible to the programmer, so that you can <br>customize the syntax however you like. Lisp is widely<br>considered to be the best substrate for domain-specific<br>little languages, and programmable syntax should help make it even better.<br>The disadvantage of this approach is that we have no examples<br>of syntax to show anyone yet. We have some ideas about it,<br>but we are still working on the underlying s-expression<br>language. Some things are fairly predictable, like<br>infix math. But we want to get the most bang for the buck<br>for desirable characters like \[ and \], so we will probably<br>wait to see what the most common idioms are before we<br>decide what to abbreviate.<br>Here are a couple ideas:<br>x.y and x:y for<br>(x y) and (x 'y) respectively.<br>\[\+ \_ 1\] for (fn (x) (+ x 1))<br>We also plan to let programmers omit<br>parentheses where no ambiguity would result, and show<br>structure by indentation instead of parentheses. I find<br>that I spontaneously do both these things when writing<br>Lisp by hand on whiteboards or the backs of envelopes.<br>* * *<br>6\. Arc Core<br>\- eval, car, cdr, cons, quote<br>\- cond split into cond + do (progn)<br> CL: (cond ((a x) (princ "!") (b x))<br> ((c x) (d x))<br> (t (e x)))<br> Arc: (cond (a x) (do (pr "!") (b x))<br> (c x) (d x)<br> (e x))<br>\- Usually use if, which binds it: (if (a x) (car it))<br>* * *<br>The core of Arc is much the same as the core of<br>McCarthy's original [1960 Lisp](https://paulgraham.com/rootsoflisp.html). The operators eval,<br>car, cdr, cons, and quote work the same when applied<br>to symbols and lists (the only data types in the 1960 paper),<br>except that car and cdr generate errors when applied to nil.<br>The one operator we changed is cond. McCarthy,<br>who wanted to keep his axioms to a minimum, buried<br>progn within cond. That worked for his examples, but <br>for programming in general you soon find you need a<br>progn separate from the implicit progn of cond.<br>Having an implicit progn in cond means every cond<br>clause has to have an extra pair of parentheses.<br>McCarthy said later that he thought he had gotten cond wrong,<br>that it used too many parentheses, and this may be<br>what he meant. Arc's cond doesn't have an implicit<br>progn, and so you don't need the parentheses around<br>each clause. We also omitted the t in the default <br>clause, which seemed to be an onion. The example<br>in the slide shows the same code in Common Lisp and<br>in Arc. (Arc's do is Common Lisp progn, and pr is<br>Common Lisp princ.)<br>In Arc, cond is a low-level operator, used mainly in<br>macroexpansions. Most of the time programmers use<br>if, which is exactly the same, except that within a<br>successful then-expression, the variable it will be<br>bound to the result of the test-expression.<br>* * *<br>7\. Assignment (Scope)<br>\- Lexical scope, single namespace.<br>\- = is setf (no set or setq).<br>\- Can create local vars by assignment.<br> \> (do (= x 5)<br> (cons x 'a))<br> (5 . A)<br> <br>\- Any sequence of code is a block.<br>\- Easy to write a non-scope block.<br>* * *<br>Arc has lexical scope and a single namespace like Scheme.<br>A variable whose value is a function is no different from any<br>other. The evaluation rule is simply to evaluate the whole<br>expression from left to right, and then apply the value of<br>the first element to the values of the rest.<br>The assignment operator is =. I was dubious about this,<br>but decided to try it and see if I got used to it. It<br>turns out to work well, even in prefix. Stripes stand<br>out, which is why they get used on<br>warning signs and poisonous animals.<br>Here is a big difference between Arc and previous Lisps:<br>local variables can be created implicitly by assigning<br>them a value. If you do an assignment to a variable that<br>doesn't already exist, you thereby create a lexical<br>variable that lasts for the rest of the block. (Yes,<br>we know this will make the code hard to compile, but <br>we're going to try.) A block is a do, or any implicit<br>do in one of Arc's predefined operators.<br>It's easy to write a progn-like operator that doesn't<br>have an effect on scopes: just write a function that takes<br>any number of arguments and returns the last. Arc has<br>a function, currently called justdo, that does this, but it is<br>intended for use only in macros where you have to<br>evaluate expressions sequentially without having them<br>unexpectedly be in a new lexical contour.<br>* * *<br>8\. Functions and Macros<br>\- lambda is fn: (fn (x) (cons x 'a))<br>\- rfn (a macro) instead of labels.<br> (rfn len (x)<br> (if (no x)<br> 0<br> (\+ 1 (len (cdr x)))))<br>\- Macros separate 1st class objs.<br> (macro (test . body)<br> \`(if ,test (do ,.body)))<br>\- To get local macros, just bind.<br>* * *<br>Like any Lisp, Arc has first-class functions. There is a<br>fn operator, like Scheme's lambda, that returns a new<br>function. Arc has no labels or letrec. For defining<br>recursive functions there is a macro called rfn, which<br>is like fn except that it takes an additional<br>first argument to use as its own name.<br>The example above is a recursive function that finds<br>the length of a list.<br>Using rfn instead of labels makes it more convenient to <br>define individual recursive functions and less convenient<br>to define several mutually-recursive functions, but the<br>former is by far the more common case.<br>(The name rfn was suggested by Dorai Sitaram.)<br>Arc macros are also first class objects.<br>They are, as in Common Lisp, simply functions that return<br>expressions. Arc doesn't have the hygienic macros of<br>Scheme or Dylan. Or rather it doesn't require you to use<br>them; something like that may be supplied as a library, <br>but programmers can also have access to raw macroexpansion.<br>This is another case where our axiom that the user is<br>a good programmer simplifies<br>matters. As an expert, the user will not be<br>thrown by the prospect of variable capture (indeed will<br>often do it deliberately), but will definitely not like<br>a macro mechanism that takes away some of the power of<br>defmacro.<br>Because macros are first-class objects, there is no need<br>for Common Lisp's macrolet. You can give a macro local<br>scope with let, just as you would give a value to any<br>other variable.<br>Making macros first-class objects may wreak havoc with<br>compilation. We're hoping that between inference and<br>declarations that it will be possible to get fast code when<br>it's needed.<br>Macros are going to be a focus in Arc, because<br>we think they're one of the<br>biggest wins in Lisp. As well as traditional expression-based<br>macros, Arc may have macros driven by code-walkers<br>looking at multiple expressions. This may interact with Arc's<br>programmable syntax in useful ways.<br>* * *<br>9\. Binding<br>\- with like CL let:<br> \> (with (x 'a y 'b)<br> (list x y))<br> (A B)<br>\- let for single variable case:<br> \> (let x 'a<br> (cons x 5))<br> (A . 5)<br>\- both macros on function call <br>* * *<br>Arc has a macro for introducing new variable bindings<br>called with. It's like the let of Common Lisp and <br>Scheme, except that it uses fewer parentheses.<br>In my Scheme and Common Lisp code, most lets introduce<br>one variable. So in Arc we use the name let for this<br>more common case.<br>Both with and let are the obvious macros on function<br>application. For example, (let x 3 (foo x)) expands into<br>((fn (x) (foo x)) 3).<br>Whenever possible, operators like these that can be<br>implemented in Arc will be officially defined by a<br>piece of Arc source code. They need not be implemented<br>this way, or described this way in tutorials, but if<br>a programming languge is good, source code should<br>make the best spec.<br>* * *<br>10\. Iteration<br>\- CL do is hard to read. Solve the common cases.<br>\- Arc's 4 basic iterators:<br> \> (for (= i 0) (< i 10) (++ i)<br> (pr i))<br> 0123456789<br> NIL<br> \> (to i 10 (pr i))<br> 0123456789<br> NIL<br> \> (each x '(a b c) (pr x))<br> ABC<br> NIL<br> \> (let i 0<br> (while (< (++ i) 10) (pr i)))<br> 123456789<br> NIL<br>\- Like with and let, macros on function calls<br>* * *<br>Forms for iteration are another open question in the Lisp<br>community. The traditional Lisp do is general but too hard<br>to read. If do was a natural way to express iterations, I<br>would by now be used to it, but when I see a do<br>I have to stop and decode it, and when I write one I have<br>to stop and figure out how to express the iteration I want.<br>In other words, do feels like object code.<br>Our take on iteration is that there are a handful of common<br>cases. If you support those directly, you'll catch nearly<br>all the interations people actually write. If anyone misses<br>do enough, they can always write it as a macro.<br>Arc has four iteration operators: for, which is like C's<br>for except that bindings created by the initialization<br>forms are local variables in the loop body; to, which is<br>like Common Lisp's dotimes but without the form for a<br>return value; each, which is like Common Lisp's dolist,<br>but works for any compound data object (lists, strings,<br>vectors, etc), and again has no return value form, <br>and while, which evaluates its body while a test expression<br>returns true.<br>All of these iteration operators are defined (though not<br>necessarily implemented) as the obvious macros on<br>recursive function application.<br>* * *<br>11\. Iteration Captures<br>\- while captures it:<br> (while (read) (pr it))<br>\- All capture keep and sum:<br> \> (each x '("al" "bob" "joe")<br> (if (> (len x) 2) (keep x)))<br> ("bob" "joe")<br> \> (to x 5<br> (sum x)<br> (pr x))<br> 01234<br> 10<br>(Can't use both.)<br>* * *<br>Like if, while leaves the variable it bound to the value<br>returned by the test expression.<br>In addition, all the iteration operators leave keep and<br>sum bound within the body to functions that accumulate values.<br>Calling keep accumulates a list of values and<br>calling sum accumulates a sum. You can call either one<br>wherever in the loop you want, and as often as you want,<br>but you can't call both in the same loop. If you do<br>call keep or sum, the iteration expression will return the<br>accumulated value, otherwise it will return nil.<br>We may generalize accumulation to allow any function to be<br>applied to the accumulated value, and maybe write keep<br>and sum as macros on this.<br>* * *<br>12\. Data Types<br>Symbol <br>Number (same as CL)<br>Cons <br>Character <br>String <br>Array <br>Class, Obj <br>DB (hash/alist) <br>Function <br>Macro <br>Likely more<br>* * *<br>Here is a quick list of the data types so far. They're<br>about what you'd expect. We're very likely to add<br>more once we get to dealing with things like threads and<br>exceptions.<br>* * *<br>13\. Compounds = Functions on Indices<br>\> ("hello" 2)<br>\\l<br>\> (map "carpet" '(3 4 1 2))<br>(\\p \\e \\a \\r)<br>CL: (aref a 5)<br>C: a\[5\]<br>Arc: (a 5)<br>* * *<br>Any compound data object (meaning one with several separately<br>addressable parts) behaves like a function on indices. <br>So for example to get the third element of a list you<br>"call" the list with 2 as an argument. This makes programs<br>shorter and saves us having separate access functions for<br>each data type.<br>You can literally use compound data objects anywhere you<br>could use a function, including as the first argument to<br>map (like Common Lisp's mapcar, but works on any sequence).<br>* * *<br>14\. Strings Work Like Lists<br>\> (car "abc") <br>\\a<br>\> (cons \\a "bc")<br>"abc"<br>Contagion as with ints and floats<br> \> (\+ "abc" '(d e))<br> (\\a \\b \\c D E)<br>Should we allow nonchars in strings?<br>* * *<br>This one is a bit of a radical idea, but we thought we <br>would try it and see how it works. In Arc, strings work<br>like lists: the car of a string is a character, and the<br>cdr is another string with the same characters except<br>the first.<br>We've found recursion on lists to be a very useful technique,<br>and so maybe it will be equally good for processing strings.<br>This could be terribly inefficient, of course, and we plan<br>to let the programmer declare when he wants to that he<br>doesn't need to do this to some strings and they should be<br>represented as simple contiguous chunks of memory (i.e.<br>unboxed).<br>This raises an interesting possibility. When strings are<br>in effect lists, why not let the programmer insert arbitrary<br>objects into them? It could be useful to insert some<br>object that had its own pr method, for example. So far<br>strings can only contain characters, but we'll see.<br>When you combine strings with lists, you get something<br>like floating point contagion. Strings are a specific<br>kind of list, like integers are a specific kind of<br>real number, and when you combine you get a result of<br>the more general type.<br>* * *<br>15\. Classes and Objects<br>Single inheritance (may change)<br>(= pt (class nil 'x 0 'y 0)) <br>(type pt (x 0) (y 0))<br>(= p1 (new pt)) <br>\> (p1 'x)<br>0<br>\> (\+\+ (p1 'x))<br>1<br>* * *<br>We look on object-oriented programming as a type of<br>abstraction that is often useful, rather than an end in itself. <br>The real test of<br>a feature is whether it will actually make your source<br>code shorter and simpler. To start with at least<br>Arc has a minimal object system that lets you do the<br>things we know people need to do.<br>Classes are first-class objects that you can create<br>with the class operator. It takes a parent object (or<br>nil) followed by a list of field names alternating with <br>default values. Field names can be anything, not just<br>symbols. There is also type macro that expands into a<br>call to class, for the common case of a named class<br>with no parent and field names that are symbols; the syntax<br>is very like Common Lisp's defstruct.<br>There is only single inheritance so far. It would not<br>be difficult to have multiple inheritance, but a poll<br>of eminent hacker friends indicated that none of them <br>found it super useful.<br>You can make an instance of a class by calling new on <br>the class. You refer to fields in instances (or<br>classes, if you want to) the same way you refer to<br>part of any compound data structure, by calling<br>the object as a function on indices, in this case<br>field names.<br>* * *<br>16\. Overloading<br>\- Anything can be an obj field name.<br>\- Overload by using a fn as a name.<br> (= pt (class nil<br> 'x 0<br> 'y 0<br> pr my-pr))<br>\- Means dispatch on first arg.<br>\- (Not great for cons, so<br>maybe a way to declare pivotal arg of<br>a function.) <br>* * *<br>You can overload a function by giving an object a field<br>whose name is that function (the actual function).<br>When an expression is evaluated, if the first argument<br>is an instance (or class) with a field whose<br>name is that function, the value stored in that field<br>(which must also be a function) is called on the same<br>arguments instead.<br>In the example on the slide, pt is a class that<br>get printed differently. When pr is called on a<br>child of pt, my-pr (whatever that is) gets invoked <br>instead.<br>This plan for overloading amounts to dispatching on<br>the first argument. That doesn't work well with<br>cons, for example, where the pivotal argument is<br>really the second one. It could be that cons is <br>an anomaly (its arguments are in that order for<br>visual reasons, and that must be rare). If<br>it isn't, we may add some way of saying which is<br>the pivotal argument in a function.<br>* * *<br>17\. DBs are hashes/alists<br>(newdb eq 'x 'a 'y 'b)<br>(db x 'a y 'b)<br>\> (each x (db x 1 y 2)<br> (pr x)<br> (keep key))<br>12<br>(X Y)<br>Lookup failure returns \*fail\*<br>* * *<br>Arc has a kind of data repository called a db that you can<br>think of as a hash table, though the internal<br>representation is unspecified (in some cases the<br>compiler might choose to make it be an alist).<br>(This idea was suggested by Erann Gat.)<br>The keys of a db can be any kind of object, like field<br>names in an instance. However, you can add and remove entries whenever<br>you like, and you can also specify the function you want to<br>define equality for keys.<br>You can create a db by calling either newdb, or the shorter<br>db which assumes that lookup equality test is eq, and the<br>keys are symbols.<br>When you're doing a lookup, what do you do when you don't<br>find anything? The traditional Lisp answer (as in e.g. assoc)<br>would be to return nil, but in that case how do you<br>distinguish between not finding anything and finding nil?<br>Arc's answer is to have a global variable \*fail\* that is <br>used by lookup functions that don't find any matches.<br>It's bound to nil by default, which is the right thing nearly<br>all the time; when it isn't, you can wrap the <br>lookup in a let that binds \*fail\* to a gensym.<br>* * *<br>18\. Parameter Lists<br>Parms are symbols or (opt \| get \| ds ...)<br>(def foo (x (ds (i j)) (get m n) (opt q 'a) . z)<br> (list x i j m n q z))<br>\> (foo 1 '(red green) (db m 'a n 'b) 'hel 'lo)<br>(1 RED GREEN A B HEL (LO))<br>(Syntax will help here.)<br>\> (let (ds (x y)) '(a b)<br> (list x y))<br>(A B)<br>* * *<br>Arc allows three things in parameter lists besides ordinary<br>symbols: (opt var default) which indicates an optional<br>parameter whose value defaults to default; (ds pattern)<br>which matches a pattern of variables<br>against an incoming list, like Common Lisp destructuring-bind;<br>and (get vars) which picks one or more variables out of<br>an incoming db or instance with corresponding keys.<br>We're expecting get parameters to play the role that keyword<br>parameters do in Common Lisp, and we hope to compile calls<br>into similar code (i.e. not actually create the dbs).<br>Arc also supports rest parameters, which occur after a dot<br>in the parameter list and are assigned all the remaining<br>values in the call.<br>Because we got rid of the extra non-variable tokens that<br>get included in Common Lisp parameter lists, we can define<br>let and with as the obvious macros on function calls.<br>So for example we get the equivalent of Common Lisp's<br>destructuring-bind for free: just use a ds form as a<br>parameter to let or with. Using a get form to<br>destructure on instances will also be convenient.<br>* * *<br>19\. Speed<br>\- Moon: hard to tell what's expensive.<br>\- SICP: programs "for people to read"<br>\- Profiler should tell, not language.<br>\- Especially for server-based apps.<br>* * *<br>David Moon once told me that Lisp makes it hard for <br>programmers to tell what's expensive.<br>That sounds like a problem.<br>At the same time, Abelson and Sussman say (and I<br>agree) that "programs must be written<br>for people to read, and only incidentally for<br>machines to execute."<br>How are we to reconcile these two ideas? I agree that,<br>most of all, a language must be a good tool for<br>thinking in. That's what made Lisp good in the first place.<br>And yet, like anyone, I like fast code.<br>I think the way out is to take the burden of showing<br>what's expensive off the language. Instead of trying<br>to make the language suggest what's expensive, just<br>make the language convenient for expressing ideas, and<br>have a profiler to show what's expensive.<br>The Scheme language sneakily increased the scope of the<br>language designer's powers. From very early, maybe from<br>the begining, the Scheme spec said that conforming<br>implementations must do tail call elimination. The<br>first time I read this, I thought "wait, can you require <br>this in a spec?" Arc will see this increase, and raise <br>it by some standards for profiling.<br>The way to get fast code in Arc will be to profile it<br>and then add declarations that improve efficiency where <br>needed. As in Common Lisp, declarations will be <br>optimization advice to the compiler; they should not<br>affect the meaning of the program.<br>Arc is intended for [server-based applications](https://paulgraham.com/road.html),<br>and profiling is especially good there because you can<br>profile your program's actual behavior. You don't<br>have to rely on test suites; you can watch actual users. |

|     |
| --- |
| * * * | |
