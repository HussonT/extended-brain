---
title: "Hackers and Painters"
author: Paul Graham
source: http://paulgraham.com/hp.html
year_published: Unknown
date_scraped: 2025-08-07
time_scraped: 12:14:21
word_count: 5192
scrape_method: firecrawl
tags: [paul-graham, essays, startups, programming, philosophy]
---

# Hackers and Painters

|     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- |
| ![](https://s.turbifycdn.com/aah/paulgraham/bel-7.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [![](https://s.turbifycdn.com/aah/paulgraham/bel-8.gif)](https://paulgraham.com/index.html)

|     |
| --- |
| ![Hackers and Painters](https://s.turbifycdn.com/aah/paulgraham/hackers-and-painters-3.gif)<br>May 2003<br>_(This essay is derived from a guest lecture at Harvard, which incorporated_<br>_an earlier talk at Northeastern.)_<br>When I finished grad school in computer science I went<br>to art school to study painting. A lot of people seemed surprised<br>that someone interested in computers would also be interested in painting.<br>They seemed to think that<br>hacking and painting were very different kinds of work-- that<br>hacking was cold, precise, and methodical, and that<br>painting was the frenzied expression of some primal urge.<br>Both of these images are wrong. Hacking and painting have a<br>lot in common. In fact, of all the different types of people I've<br>known, hackers and painters are among the most alike.<br>What hackers and painters have in common is that they're<br>both makers. Along with composers, architects, and writers,<br>what hackers and painters are trying to do is make good things.<br>They're not doing research per se, though if in the course of<br>trying to make good things they discover some new technique,<br>so much the better.<br>I've never liked the term "computer science." The main<br>reason I don't like it is that there's no such thing.<br>Computer science is a<br>grab bag of tenuously related areas thrown together<br>by an accident of history, like Yugoslavia.<br>At one end you have people who are really mathematicians,<br>but call what they're doing computer science so they can get DARPA grants.<br>In the middle you have people working on<br>something like the natural history of computers-- studying the<br>behavior of algorithms for routing data through<br>networks, for example. And then at the other extreme you<br>have the hackers, who are trying to<br>write interesting software, and for whom computers are just a<br>medium of expression, as concrete is for architects or<br>paint for painters. It's as if<br>mathematicians, physicists, and architects all had to be in<br>the same department.<br>Sometimes what the hackers do is called "software engineering,"<br>but this term is just as misleading.<br>Good software designers are no more engineers than architects are.<br>The border between architecture and engineering is not sharply<br>defined, but it's there.<br>It falls between what and how: architects decide what to do,<br>and engineers figure out how to do it.<br>What and how should not be kept too separate. You're<br>asking for trouble if you try to decide what to do without<br>understanding how to do it.<br>But hacking can certainly be more than just deciding how to<br>implement some spec. At its best, it's creating the spec-- though<br>it turns out the best way to do that is to implement it.<br>Perhaps one day<br>"computer science" will, like Yugoslavia, get broken up into its<br>component parts. That might be a good thing. Especially if it<br>meant independence for my native land, hacking.<br>Bundling all these different types of work together in one<br>department may be convenient administratively, but it's confusing<br>intellectually. That's the other reason I don't like the name<br>"computer science." Arguably the people in the middle are doing<br>something like an experimental science. But the people at either<br>end, the hackers and the mathematicians, are not actually doing science.<br>The mathematicians don't seem bothered by this. They happily<br>set to work proving theorems like the other mathematicians<br>over in the math department, and probably soon stop noticing<br>that the building they work in says \`\`computer science'' on the<br>outside. But for the hackers this label is a problem.<br>If what they're doing is called science, it makes them feel they<br>ought to be acting scientific.<br>So instead of doing what they really want to do, which is <br>to design beautiful software, hackers in universities and<br>research labs feel they ought to be writing research papers.<br>In the best case, the papers are just a formality. Hackers write<br>cool software, and then write a paper about it, and the paper<br>becomes a proxy for the achievement represented by the software.<br>But often this mismatch causes problems. It's easy to<br>drift away from building beautiful things toward building ugly<br>things that make more suitable subjects for research papers.<br>Unfortunately, beautiful things don't always make the<br>best subjects for papers.<br>Number one, research must be original-- and<br>as anyone who has written a PhD dissertation knows, the way to<br>be sure that you're exploring virgin territory is to stake<br>out a piece of ground that no one wants. Number two, research must be<br>substantial-- and awkward systems yield meatier papers,<br>because you can write about the obstacles you have to overcome<br>in order to get things done. Nothing yields meaty problems like<br>starting with the wrong assumptions. Most of AI is an example<br>of this rule; if you assume that knowledge can be represented<br>as a list of predicate logic expressions whose arguments represent<br>abstract concepts, you'll have a lot of<br>papers to write about how to make this work. As Ricky Ricardo<br>used to say, "Lucy, you got a lot of explaining to do."<br>The way to create something beautiful is often to make subtle<br>tweaks to something that already exists, or to combine existing<br>ideas in a slightly new way. This kind of work is hard to<br>convey in a research paper.<br>So why do universities and research labs continue to judge<br>hackers by publications?<br>For the same reason that "scholastic aptitude"<br>gets measured by simple-minded standardized tests, or<br>the productivity of programmers gets measured in lines of code.<br>These tests<br>are easy to apply, and there is nothing so tempting as an easy test<br>that kind of works.<br>Measuring what hackers are actually trying to do, designing<br>beautiful software, would be much more difficult. You need<br>a good [sense of design](https://paulgraham.com/taste.html) to judge <br>good design. And<br>there is no correlation, except possibly<br>a [negative](http://www.apa.org/journals/features/psp7761121.pdf) <br>one, between people's ability to recognize good<br>design and their confidence that they can.<br>The only external test is time. Over time, beautiful<br>things tend to thrive, and ugly<br>things tend to get discarded. Unfortunately, the amounts of time<br>involved can be longer than human lifetimes. Samuel Johnson<br>said it took a hundred years for a writer's reputation to<br>converge. You have to wait for the writer's<br>influential friends to die, and then for all their followers<br>to die.<br>I think hackers just have to resign themselves to having a large random<br>component in their reputations. In this they are no different<br>from other makers. In fact, they're lucky by comparison. <br>The influence of fashion is not nearly so great in hacking as it<br>is in painting.<br>There are worse things than having people misunderstand your<br>work. A worse danger is that you<br>will yourself misunderstand your work. Related fields are<br>where you go looking for ideas. If you find yourself in the computer science<br>department, there is a natural temptation to believe, for example,<br>that hacking is the applied version of what theoretical computer<br>science is the theory of. All<br>the time I was in graduate school I had an uncomfortable feeling<br>in the back of my mind that I ought to know more theory,<br>and that it was very remiss of me to have forgotten all that<br>stuff within three weeks of the final exam.<br>Now I realize I was<br>mistaken. Hackers need to understand the theory of computation<br>about as much as painters need to understand paint chemistry.<br>You need to know how to calculate time and<br>space complexity and about<br>Turing completeness. You might also want to remember at<br>least the concept of a state machine, in case you have to write<br>a parser or a regular expression library. Painters in fact <br>have to remember a good deal more about paint chemistry than <br>that.<br>I've found that the best sources of ideas<br>are not the other fields that have the word "computer" in<br>their names, but the other fields inhabited by makers.<br>Painting has been a much richer source of ideas than the<br>theory of computation.<br>For example, I was taught in college<br>that one ought to figure out a program<br>completely on paper<br>before even going near a computer. I found that I did not<br>program this way. I found that I liked to program<br>sitting in front of a computer, not a piece of paper. Worse<br>still, instead of patiently writing out a complete program<br>and assuring myself it was correct, I tended to just spew<br>out code that was hopelessly broken, and gradually beat it into<br>shape. Debugging, I was taught, was a kind of final pass where<br>you caught typos and oversights. The way I worked, it<br>seemed like programming consisted of debugging.<br>For a long time I felt bad about this, just as I once<br>felt bad that I didn't hold my pencil the way they taught me<br>to in elementary school.<br>If I had only looked over at<br>the other makers, the painters or the architects, I would<br>have realized that there was a name for what I was doing:<br>sketching. As far as I can tell, the<br>way they taught me to program in college was all wrong.<br>You should figure out programs as you're writing them,<br>just as writers and painters and architects do.<br>Realizing this has real implications for software design.<br>It means that a programming language should, above all, be<br>malleable. A programming language is for <br>[thinking](https://paulgraham.com/piraha.html) of<br>programs, not for expressing programs you've already thought<br>of. It should be a pencil, not a pen. Static typing would<br>be a fine idea if people actually did write programs the way<br>they taught me to in college. But that's not how any of the <br>hackers I know write programs. We need a language that lets us<br>scribble and smudge and smear, not a language where you have<br>to sit with a teacup of types balanced on your knee and make<br>polite conversation with a strict old aunt of a compiler.<br>While we're on the subject of static typing, identifying with<br>the makers will save us from another problem that afflicts<br>the sciences: math envy. Everyone in the sciences<br>secretly believes that mathematicians are smarter than they are. <br>I think mathematicians also believe this. At any rate,<br>the result is that scientists tend to make their<br>work look as mathematical as possible. In a field like<br>physics this probably doesn't do much harm, but the further you<br>get from the natural sciences, the more of a problem it<br>becomes.<br>A page of formulas just looks so impressive.<br>(Tip: for extra impressiveness, use Greek variables.) And<br>so there is a great temptation to work on problems you<br>can treat formally, rather than problems that are, say,<br>important.<br>If hackers identified with other makers, like writers and<br>painters, they wouldn't feel tempted to do <br>this. Writers and painters don't suffer from math envy.<br>They feel as if they're doing something completely unrelated.<br>So are hackers, I think.<br>If universities and research labs keep hackers from doing<br>the kind of work they want to do,<br>perhaps the place for them is in companies.<br>Unfortunately, most companies won't let hackers do what they<br>want either. Universities and research labs force hackers<br>to be scientists, and companies force them to be engineers.<br>I only discovered this myself quite recently. When Yahoo bought<br>Viaweb, they asked me what I wanted to do. I had never<br>liked the business side very much, and said that I just wanted to<br>hack. When I got to Yahoo, I found that what hacking meant<br>to them was implementing software, not designing it. Programmers<br>were seen as technicians who translated the visions (if<br>that is the word) of product managers into code.<br>This seems to be the<br>default plan in big companies. They do it because<br>it decreases the standard deviation of the outcome.<br>Only a small percentage of hackers can actually design software,<br>and it's hard for the<br>people running a company to pick these out. So instead of<br>entrusting the future of the software to<br>one brilliant hacker, most companies set things up so that it is<br>designed by committee, and the hackers merely<br>implement the design.<br>If you want to make money at some point, remember this,<br>because this is one of the reasons startups win. Big companies want<br>to decrease the standard deviation of design outcomes because they<br>want to avoid disasters. But when you damp oscillations, you<br>lose the high points as well as the low. This is not a problem for<br>big companies, because they don't win by making great<br>products. Big companies win by sucking less than other big companies.<br>So if you can figure out a way to get in a<br>design war with a company big enough that its software is <br>designed by product managers, they'll never be able to keep up<br>with you. These opportunities are not easy to find, though.<br>It's hard to engage a big company in a design war,<br>just as it's hard to engage an opponent inside a castle in hand<br>to hand combat. It would be pretty easy to write a better<br>word processor than Microsoft Word, for example, but Microsoft,<br>within the castle of their operating system monopoly,<br>probably wouldn't even notice if you did.<br>The place to fight design wars is in new markets, where no one<br>has yet managed to establish any fortifications. That's where<br>you can win big by taking the bold approach to design, and<br>having the same people both design and implement the product. <br>Microsoft themselves did this at the start. So did Apple.<br>And Hewlett-Packard. I suspect almost every successful startup<br>has.<br>So one way to build great software is to start your own<br>startup. There are two problems with this, though. One is<br>that in a startup you have to do so much besides write software.<br>At Viaweb I considered myself lucky if I<br>got to hack a quarter of the time. And the things I had to <br>do the other three quarters of the time ranged from tedious<br>to terrifying. I have a benchmark for this, because I<br>once had to leave a board meeting to have<br>some cavities filled. I remember sitting back in the<br>dentist's chair, waiting for the drill, and feeling like<br>I was on vacation.<br>The other problem with startups is that there is not much<br>overlap between the kind of software that makes money and the<br>kind that's interesting to write. Programming languages<br>are interesting to write, and Microsoft's first product was<br>one, in fact, but no one will pay for programming languages<br>now. If you want to make money, you tend to be forced to work<br>on problems that are too nasty for anyone to solve for free.<br>All makers face this problem. Prices are<br>determined by supply and demand, and there is just not as much<br>demand for things that are fun to work on as there is for<br>things that solve the mundane problems of individual customers.<br>Acting in off-Broadway plays just doesn't pay as well as<br>wearing a gorilla suit in someone's booth at a<br>trade show. Writing novels doesn't pay as well as writing<br>ad copy for garbage disposals.<br>And hacking programming languages doesn't pay as well<br>as figuring out how to connect some company's<br>legacy database to their Web server.<br>I think the answer to this problem, in the case of software,<br>is a concept known to nearly all makers: the day job.<br>This phrase began with musicians, who<br>perform at night. More generally, it means that you have one<br>kind of work you do for money, and another for love.<br>Nearly all makers have day jobs early in their careers.<br>Painters and writers notoriously do. If you're lucky<br>you can get a day job that's closely<br>related to your real work. Musicians often<br>seem to work in record stores. A hacker working on some<br>programming language or operating system might likewise be able to<br>get a day job using it. \[1\]<br>When I say that the answer is for hackers to have day jobs, <br>and work on beautiful software on the side, I'm not proposing<br>this as a new idea. This is what open-source hacking is all <br>about. What I'm saying is that open-source is probably the right<br>model, because it has been independently confirmed by all the <br>other makers.<br>It seems surprising to me that any employer would be reluctant<br>to let hackers work on open-source projects.<br>At Viaweb, we would have been reluctant to hire anyone<br>who didn't. When we interviewed<br>programmers, the main<br>thing we cared about was what kind of software they<br>wrote in their spare time.<br>You can't do anything really well unless<br>you love it, and if you love to hack you'll inevitably<br>be working on projects of your own. \[2\]<br>Because hackers are makers rather than scientists,<br>the right place to look for metaphors is not in the<br>sciences, but among other kinds of makers. What else can painting<br>teach us about hacking?<br>One thing we can learn, or at least confirm, from the<br>example of painting is how to learn to hack. You learn to<br>paint mostly by doing it.<br>Ditto for hacking. Most hackers don't learn to hack by<br>taking college courses in programming. They learn to hack<br>by writing programs of their own at age thirteen. Even in <br>college classes, you learn to hack mostly by hacking. \[3\]<br>Because painters leave a trail of work behind them, you<br>can watch them learn by doing. If you look at the work<br>of a painter in chronological order, you'll find that each <br>painting builds on things that have been learned in previous<br>ones. When there's something in<br>a painting that works very well, you can usually find version <br>1 of it in a smaller form in some earlier painting.<br>I think most makers work this way. Writers and architects seem<br>to as well. Maybe it would be good for hackers<br>to act more like painters, and regularly start over from scratch,<br>instead of continuing to work for years on one project, and<br>trying to incorporate all their later ideas as revisions.<br>The fact that hackers learn to hack by doing it is another<br>sign of how different hacking is from the sciences. Scientists<br>don't learn science by doing it, but by doing labs and problem sets.<br>Scientists start out doing work that's perfect, in the sense<br>that they're just trying to reproduce work someone else has <br>already done for them.<br>Eventually, they get<br>to the point where they can do original work.<br>Whereas hackers, from the start, are doing original work; it's<br>just very bad. So hackers start original, and get good, and<br>scientists start good, and get original.<br>The other way makers learn is from examples.<br>For a painter, a museum is a reference library of techniques.<br>For hundreds of years it has been part of the traditional<br>education of painters to copy the works of the great masters,<br>because copying forces you to look closely<br>at the way a painting is made.<br>Writers do this too.<br>Benjamin Franklin learned to write by summarizing the points <br>in the essays of Addison and Steele and then trying to<br>reproduce them. Raymond Chandler did the same thing<br>with detective stories.<br>Hackers, likewise, can learn to program by looking at <br>good programs-- not just at what they do, but the source<br>code too. One of the less publicized benefits<br>of the open-source movement is that it has made it easier<br>to learn to program. When I learned to program, we had to rely<br>mostly on examples in books. The one big chunk of<br>code available then was Unix, but even this was not <br>open source. Most of the people who read the source<br>read it in illicit photocopies of John Lions' book, which<br>though written in 1977 was not allowed to be published<br>until 1996.<br>Another example we can take from painting is the way that<br>paintings are created by gradual refinement. Paintings usually<br>begin with a sketch.<br>Gradually the details get filled in.<br>But it is not merely a process of filling in. Sometimes <br>the original plans turn out to be mistaken.<br>Countless paintings,<br>when you look at them in xrays, turn out to have limbs that<br>have been moved or facial features that have been readjusted.<br>Here's a case where we can learn from painting. I think hacking<br>should work this way too. It's unrealistic<br>to expect that the specifications for a program will be<br>perfect. You're<br>better off if you admit this up front, and write programs in<br>a way that allows specifications to change on the fly.<br>(The structure of large companies makes this hard for them<br>to do, so here is another place where startups have an advantage.)<br>Everyone by now presumably knows about the danger of premature<br>optimization. I think we should be just as worried about<br>premature design-- deciding too early what<br>a program should do.<br>The right tools can help us avoid<br>this danger.<br>A good programming language should, like oil paint, make it<br>easy to change your mind. Dynamic typing is a win here because<br>you don't have to<br>commit to specific data representations up front.<br>But the key to flexibility, I think, is to make the language<br>very [abstract](https://paulgraham.com/power.html).<br>The easiest program to change is one that's very short.<br>This sounds like a paradox, but a great painting<br>has to be better than it has to be.<br>For example, when Leonardo<br>painted the portrait of [Ginevra de Benci](https://paulgraham.com/ginevra.html)<br>in the National Gallery, he put a juniper bush behind her head.<br>In it he carefully<br>painted each individual leaf. Many painters might have thought,<br>this is just something to put in the background to frame<br>her head. No one will look that closely at it.<br>Not Leonardo. How hard he worked on part of a painting didn't<br>depend at all on how closely he expected anyone to look at it.<br>He was like Michael Jordan. Relentless.<br>Relentlessness wins because, in the aggregate, unseen details<br>become visible.<br>When people walk by the portrait of Ginevra de Benci,<br>their attention is often immediately arrested by it,<br>even before they look at the label and notice that it says<br>Leonardo da Vinci. All those unseen details combine to produce<br>something that's just stunning, like a thousand barely audible<br>voices all singing in tune.<br>Great software, likewise, requires a fanatical devotion to<br>beauty. If you look inside good software, you find that<br>parts no one is ever supposed to see are beautiful too.<br>I'm not claiming I write great software, but I<br>know that when it comes to code I behave in a way that would<br>make me eligible for prescription drugs if I approached everyday<br>life the same way.<br>It drives me crazy to see code that's badly indented,<br>or that uses ugly variable names.<br>If a hacker were a mere implementor, turning a spec into code, then<br>he could just work his way through it from one end to the other like<br>someone digging a ditch. But if the hacker is a creator, we have<br>to take inspiration into account.<br>In hacking, like painting,<br>work comes in cycles. Sometimes you get excited about some<br>new project and you want to work sixteen hours a day on it. <br>Other times nothing seems interesting.<br>To do good work you have to take these cycles into<br>account, because they're affected by how you react to them.<br>When you're driving a<br>car with a manual transmission on a hill, you have to back off<br>the clutch sometimes to avoid stalling. Backing<br>off can likewise prevent ambition from stalling.<br>In both painting and hacking there are some<br>tasks that are terrifyingly ambitious, and others that are<br>comfortingly routine. It's a good idea to save some easy<br>tasks for moments when you would otherwise stall.<br>In hacking, this can literally mean saving up bugs.<br>I like debugging: it's the<br>one time that hacking is as straightforward as <br>people think it is. You have a<br>totally constrained problem, and all you have to do is solve<br>it. Your program is supposed to do x. Instead it does y.<br>Where does it go wrong? You know you're going to win<br>in the end. It's as relaxing as painting a wall.<br>The example of painting can teach us not only how to manage our<br>own work, but how to work together. A lot of the<br>great art of the past is the work of multiple hands, though<br>there may only be one name on the wall next to it in the<br>museum. Leonardo was an apprentice in the workshop of<br>Verrocchio and painted one of the angels in his [Baptism of\<br>Christ](https://paulgraham.com/baptism.html). This sort of thing was the rule, not the exception.<br>Michelangelo was considered especially dedicated for insisting<br>on painting all the figures on the ceiling of the Sistine<br>Chapel himself.<br>As far as I know, when painters worked together on a painting,<br>they never worked on the same parts. It was common<br>for the master to paint the principal figures and for assistants<br>to paint the others and the background. But you never had<br>one guy painting over the work of another.<br>I think this is the right model for collaboration in software<br>too. Don't push it too far. When a piece of code is<br>being hacked by three or four different people, no one of whom<br>really owns it, it will end up being like a common-room. It will<br>tend to feel bleak and abandoned, and accumulate cruft.<br>The right<br>way to collaborate, I think, is to divide projects into sharply<br>defined modules, each with a definite owner, and with interfaces<br>between them that are as carefully designed and, if possible,<br>as articulated as programming languages.<br>Like painting, most software is intended for<br>a human audience. And so hackers, like painters, must have<br>empathy to do really great work. You have to be able to see<br>things from the user's point of view.<br>When I was a kid I was always being told to look at things from<br>someone else's point of view. What this always meant in<br>practice was to do what someone else wanted, instead of what<br>I wanted. This of course gave empathy a bad name, and I made a<br>point of not cultivating it.<br>Boy, was I wrong. It turns out that looking at things from <br>other people's point of view is practically the secret of<br>success. It doesn't necessarily mean being self-sacrificing.<br>Far from it. Understanding how someone else sees things<br>doesn't imply that you'll act in his interest; in some<br>situations-- in war, for example-- you want to do exactly<br>the opposite. \[4\]<br>Most makers make things for a human audience.<br>And to engage an audience you have to understand what they need.<br>Nearly all the greatest paintings are paintings of people,<br>for example, because people are what people are interested in.<br>Empathy is probably the single most important difference<br>between a good hacker and a great one. Some hackers<br>are quite smart, but when it comes to empathy are<br>practically solipsists. It's hard for such <br>people to design great software \[5\], because they can't<br>see things from the user's point of view.<br>One way to tell how good people are at empathy is to watch<br>them explain a technical question to someone without a technical<br>background. We probably all know people who, though otherwise smart,<br>are just comically bad at this. If someone asks them at<br>a dinner party what a programming language is, they'll<br>say something like \`\`Oh, a high-level language is what<br>the compiler uses as input to generate object code.''<br>High-level language? Compiler? Object code? Someone who <br>doesn't know what a programming language is obviously doesn't<br>know what these things are, either.<br>Part of what software has to do is explain itself. So to <br>write good software you have to understand how little users <br>understand.<br>They're going to walk up to the software with no preparation, and<br>it had better do what they guess it will, because they're<br>not going to read the manual. The best system I've ever seen <br>in this respect was the original Macintosh, in 1985.<br>It did what software almost never does: it just worked. \[6\]<br>Source code, too, should explain itself. If I could get people to<br>remember just one quote about programming, it would be the<br>one at the beginning of _Structure and Interpretation of Computer_<br>_Programs._<br>> Programs should be written for people to read, and<br>> only incidentally for machines to execute.<br>You need to have <br>empathy not just for your users, but for your readers. It's in <br>your interest, because you'll be one of them.<br>Many a hacker has written a program only to<br>find on returning to it six months later that he has no idea <br>how it works. I know several people who've sworn off Perl after<br>such experiences. \[7\]<br>Lack of empathy is associated with intelligence, to the point<br>that there is even something of a fashion for it in some places.<br>But I don't think there's any correlation.<br>You can do well in math and<br>the natural sciences without having to learn empathy, and people in these<br>fields tend to be smart, so the two qualities have come to be<br>associated. But there are plenty of dumb people who are bad at<br>empathy too. Just listen to the people who call in with questions on<br>talk shows. They ask whatever it is they're asking in<br>such a roundabout way<br>that the hosts often have to rephrase the question for them.<br>So, if hacking works like painting and writing, is it as cool?<br>After all, you only get one life.<br>You might as well spend it working on something great.<br>Unfortunately, the question is hard to answer. There is always<br>a big time lag in prestige. It's like light from a distant star.<br>Painting has prestige now because of great work people did five hundred<br>years ago. At the time, no one thought<br>these paintings were as important as we do today. It would have<br>seemed very odd to people at the time that Federico da Montefeltro,<br>the Duke of Urbino, would one day be known mostly as the guy<br>with the strange nose in a [painting](https://paulgraham.com/montefeltro.html) <br>by Piero della Francesca.<br>So while I admit that hacking doesn't seem as cool as painting now,<br>we should remember that painting itself didn't seem as cool in<br>its glory days as it does now.<br>What we can say with some confidence is that these are the glory<br>days of hacking. In most fields the great work is done early on.<br>The paintings made between 1430 and 1500 are still unsurpassed.<br>Shakespeare appeared just as professional theater was being born,<br>and pushed the medium<br>so far that every playwright since has had to live in his shadow.<br>Albrecht Durer did the same thing with engraving, and Jane Austen<br>with the novel.<br>Over and over we see the same pattern. A new medium appears, and<br>people are so excited about it that they explore most of its<br>possibilities in the first couple generations. Hacking seems<br>to be in this phase now.<br>Painting was not, in Leonardo's time, as cool as his work<br>helped make it.<br>How cool hacking turns out to be will depend on what we can<br>do with this new medium. <br>**Notes**<br>\[1\] The greatest damage that photography has done<br>to painting may be the fact that it killed the best day job.<br>Most of the great painters in history supported<br>themselves by painting portraits. <br>\[2\] I've been told that Microsoft discourages<br>employees from contributing to open-source projects, even in<br>their spare time.<br>But so many of the best hackers work on open-source<br>projects now that the main effect of this policy may be<br>to ensure that they won't be able to hire any first-rate<br>programmers.<br>\[3\] What you learn about programming in college is much like<br>what you learn about books or clothes or dating: what bad taste you<br>had in high school.<br>\[4\] Here's an example of applied empathy.<br>At Viaweb, if we couldn't decide between two alternatives, we'd<br>ask, what would our competitors hate most? At one point a<br>competitor added a feature to their software that was basically<br>useless, but since it was one of few they had that we didn't, they<br>made much of it in the trade press.<br>We could have tried to explain that the feature was useless,<br>but we decided it would annoy our competitor more if we<br>just implemented it ourselves, so we hacked together our own<br>version that afternoon.<br>\[5\] Except text editors and compilers. Hackers don't need empathy to<br>design these, because they are themselves typical users.<br>\[6\] Well, almost. They overshot the available RAM somewhat,<br>causing much inconvenient disk swapping, but this could be fixed<br>within a few months by buying an additional disk drive.<br>\[7\] The way to make programs easy to read is not to<br>stuff them with comments. I would take Abelson and Sussman's<br>quote a step further. Programming languages should be designed<br>to express algorithms, and only incidentally to tell computers<br>how to execute them. A good programming language<br>ought to be better for explaining software than English.<br>You should only<br>need comments when there is some kind of kludge you need to warn<br>readers about, just as on a road there are only<br>arrows on parts with unexpectedly sharp curves.<br>**Thanks** to Trevor Blackwell, Robert Morris, Dan Giffin, and Lisa<br>Randall for reading drafts of this, and to Henry Leitner<br>and Larry Finkelstein for inviting me to speak. |

|     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [Japanese Translation](http://www.shiro.dreamhost.com/scheme/trans/hp-j.html)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [Spanish Translation](http://kapcoweb.com/p/hackers-y-pintores)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [German Translation](http://www.langatigma.org/trans/hm.html)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [Portuguese Translation](http://www.sounerd.com.br/index.php?option=com_content&task=view&id=203&Itemid=43)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [Czech Translation](http://blog.zvestov.cz/item/135)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [Why Good Design Comes from Bad Design](http://www.uiweb.com/issues/issue08.htm)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://s.turbifycdn.com/aah/paulgraham/japanese-translation-1.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [Knuth: Computer Programming as an Art](https://paulgraham.com/knuth.html)<br>![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |
| ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) |

|     |
| --- |
| * * *

|     |
| --- |
| ![](http://www.virtumundo.com/images/spacer.gif)<br>You'll find this essay and 14 others in<br>[**_Hackers & Painters_**](http://www.amazon.com/gp/product/0596006624).<br>![](http://www.virtumundo.com/images/spacer.gif) | | |
