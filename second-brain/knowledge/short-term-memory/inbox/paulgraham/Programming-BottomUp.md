---
title: "Programming Bottom-Up"
author: Paul Graham
source: http://paulgraham.com/progbot.html
year_published: Unknown
date_scraped: 2025-08-07
time_scraped: 13:56:49
word_count: 893
scrape_method: firecrawl
tags: [paul-graham, essays, startups, programming, philosophy]
---

# Programming Bottom-Up

|     |     |     |
| --- | --- | --- |
| ![](https://s.turbifycdn.com/aah/paulgraham/essays-5.gif) | ![](https://sep.turbifycdn.com/ca/Img/trans_1x1.gif) | [![](https://s.turbifycdn.com/aah/paulgraham/essays-6.gif)](https://paulgraham.com/index.html)

|     |
| --- |
| ![Programming Bottom-Up](https://s.turbifycdn.com/aah/paulgraham/programming-bottom-up-2.gif)<br>1993<br>_(This essay is from the introduction to_ [On Lisp](https://paulgraham.com/onlisp.html) _.)_<br>It's a long-standing principle of programming style that the functional<br>elements of a program should not be too large. If some component of a<br>program grows beyond the stage where it's readily comprehensible,<br>it becomes a mass of complexity which conceals errors as easily<br>as a big city conceals fugitives. Such software will be<br>hard to read, hard to test, and hard to debug.<br>In accordance with this principle, a large program must be divided<br>into pieces, and the larger the program, the more it must be divided.<br>How do you divide a program? The traditional approach is<br>called _top-down design:_ you say "the purpose of the<br>program is to do these seven things, so I divide it into seven major<br>subroutines. The first subroutine has to do these four things, so<br>it in turn will have four of its own subroutines," and so on.<br>This process continues until the whole program has the right level<br>of granularity-- each part large enough to do something substantial,<br>but small enough to be understood as a single unit.<br>Experienced Lisp programmers divide up their programs differently.<br>As well as top-down design, they follow a principle which<br>could be called _bottom-up design_\-\- changing the language<br>to suit the problem.<br>In Lisp, you don't just write your program down toward the language,<br>you also build the language up toward your program. As you're<br>writing a program you may think "I wish Lisp had such-and-such an<br>operator." So you go and write it. Afterward<br>you realize that using the new operator would simplify the design <br>of another part of the program, and so on.<br>Language and program evolve together.<br>Like the border between two warring states,<br>the boundary between language and program is drawn and redrawn,<br>until eventually it comes to rest along the mountains and rivers,<br>the natural frontiers of your problem.<br>In the end your program will look as if the language had been<br>designed for it.<br>And when language and<br>program fit one another well, you end up with code which is<br>clear, small, and efficient.<br>It's worth emphasizing that bottom-up design doesn't mean<br>just writing the same program in a different order. When you<br>work bottom-up, you usually end up with a different program.<br>Instead of a single, monolithic program,<br>you will get a larger language with more abstract operators, <br>and a smaller program written in it. Instead of a lintel,<br>you'll get an arch.<br>In typical code, once you abstract out the parts which are<br>merely bookkeeping, what's left is much shorter;<br>the higher you build up the language, the less distance you<br>will have to travel from the top down to it.<br>This brings several advantages:<br>1. By making the language do more of the work, bottom-up design<br>   yields programs which are smaller and more agile. A shorter<br>   program doesn't have to be divided into so many components, and<br>   fewer components means programs which are easier to read or<br>   modify. Fewer components also means fewer connections between <br>   components, and thus less chance for errors there. As<br>   industrial designers strive to reduce the number of moving parts<br>   in a machine, experienced Lisp programmers use bottom-up design<br>   to reduce the size and complexity of their programs.<br>   <br>2. Bottom-up design promotes code re-use.<br>   When you write two<br>   or more programs, many of the utilities you wrote for the first<br>   program will also be useful in the succeeding ones. Once you've <br>   acquired a large substrate of utilities, writing a new program can<br>   take only a fraction of the effort it would require if you had to <br>   start with raw Lisp.<br>   <br>3. Bottom-up design makes programs easier to read.<br>   <br>   An instance of this type<br>   of abstraction asks the reader to understand a general-purpose operator;<br>   an instance of functional abstraction asks the reader to understand<br>   a special-purpose subroutine. \[1\]<br>   <br>4. Because it causes you always to be on the lookout for patterns<br>   in your code, working bottom-up helps to clarify your ideas about<br>   the design of your program. If two distant components of a program<br>   are similar in form, you'll be led to notice the similarity and<br>   perhaps to redesign the program in a simpler way.<br>   <br>Bottom-up design is possible to a certain degree in languages<br>other than Lisp. Whenever you see library functions,<br>bottom-up design is happening. However, Lisp gives you much broader<br>powers in this department, and augmenting the language plays a<br>proportionately larger role in Lisp style-- so much so that<br>Lisp is not just a different language, but a whole different way<br>of programming.<br>It's true that this style of development is better suited to<br>programs which can be written by small groups. However, at the<br>same time, it extends the limits of what can be done by a small<br>group. In _The Mythical Man-Month_,<br>Frederick Brooks<br>proposed that the productivity of a group of programmers<br>does not grow linearly with its size. As the size of the<br>group increases, the productivity of individual programmers<br>goes down. The experience of Lisp programming <br>suggests a more cheerful way<br>to phrase this law: as the size of the group decreases, the<br>productivity of individual programmers goes up.<br>A small group wins, relatively speaking, simply because it's<br>smaller. When a small group also takes advantage of the<br>techniques that Lisp makes possible, it can <br>[win outright](https://paulgraham.com/avg.html).<br>**New:** [Download On Lisp for Free](https://paulgraham.com/onlisptext.html).<br>* * *<br>\[1\] "But no one can read<br>the program without understanding all your new utilities."<br>To see why such statements are usually mistaken,<br>see Section 4.8. |

|     |
| --- |
| * * * | |
